"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
var _exportNames = {
  BzzFS: true
};
exports.BzzFS = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _fs = require("fs");

var _path = require("path");

var _bzzNode = require("@erebos/bzz-node");

var _tarFs = _interopRequireDefault(require("tar-fs"));

var _fs2 = require("./fs");

Object.keys(_fs2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  exports[key] = _fs2[key];
});

class BzzFS {
  constructor(config) {
    (0, _defineProperty2.default)(this, "bzz", void 0);
    (0, _defineProperty2.default)(this, "resolvePath", void 0);
    const {
      basePath,
      bzz
    } = config;
    this.bzz = bzz instanceof _bzzNode.BzzNode ? bzz : new _bzzNode.BzzNode({
      url: bzz
    });
    this.resolvePath = basePath ? path => (0, _path.resolve)(basePath, path) : path => path;
  }

  async downloadTarTo(hash, toPath, options = {}) {
    const res = await this.bzz.downloadTar(hash, options);
    await (0, _fs2.writeStreamTo)(res.body, this.resolvePath(toPath));
  }

  async downloadFileTo(hash, toPath, options = {}) {
    const res = await this.bzz.download(hash, options);
    await (0, _fs2.writeStreamTo)(res.body, this.resolvePath(toPath));
  }

  async downloadDirectoryTo(hash, toPath, options = {}) {
    const res = await this.bzz.downloadTar(hash, options);
    return await (0, _fs2.extractTarStreamTo)(res.body, this.resolvePath(toPath));
  }

  async downloadTo(hash, toPath, options = {}) {
    const path = this.resolvePath(toPath);

    if (await (0, _fs2.isFile)(path)) {
      await this.downloadFileTo(hash, path, options);
    } else {
      await this.downloadDirectoryTo(hash, path, options);
    }
  }

  async uploadFileFrom(fromPath, options = {}) {
    var _options$size;

    const path = this.resolvePath(fromPath);
    const size = (_options$size = options.size) != null ? _options$size : await (0, _fs2.getSize)(path);
    return await this.bzz.uploadFile((0, _fs.createReadStream)(path), { ...options,
      size
    });
  }

  async uploadTarStream(stream, options = {}) {
    return await this.bzz.uploadFile(stream, { ...options,
      contentType: 'application/x-tar'
    });
  } // path must be either a tar archive or a directory


  async uploadTar(fromPath, options = {}) {
    const path = this.resolvePath(fromPath);
    const stream = (await (0, _fs2.isFile)(path)) ? (0, _fs.createReadStream)(path) : _tarFs.default.pack(path);
    return await this.uploadTarStream(stream, options);
  }

  async uploadDirectoryFrom(fromPath, options = {}) {
    const path = this.resolvePath(fromPath);
    return await this.uploadTarStream(_tarFs.default.pack(path), options);
  }

  async uploadFrom(fromPath, options = {}) {
    const path = this.resolvePath(fromPath);
    return (await (0, _fs2.isFile)(path)) ? await this.uploadFileFrom(path, options) : await this.uploadDirectoryFrom(path, options);
  }

}

exports.BzzFS = BzzFS;