"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.getSize = getSize;
exports.isFile = isFile;
exports.writeStreamTo = writeStreamTo;
exports.extractTarStreamTo = extractTarStreamTo;

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _fsExtra = require("fs-extra");

var _tarStream = _interopRequireDefault(require("tar-stream"));

async function getSize(path) {
  const stats = await (0, _fsExtra.stat)(path);
  return stats.size;
}

async function isFile(path) {
  const stats = await (0, _fsExtra.stat)(path);
  return stats.isFile();
}

async function writeStreamTo(stream, filePath) {
  await (0, _fsExtra.ensureDir)(_path.default.dirname(filePath));
  await new Promise((resolve, reject) => {
    stream.pipe((0, _fs.createWriteStream)(filePath)).on('error', err => {
      reject(err);
    }).on('finish', () => {
      resolve();
    });
  });
}

async function extractTarStreamTo(stream, dirPath) {
  await (0, _fsExtra.ensureDir)(dirPath);
  return await new Promise((resolve, reject) => {
    const extract = _tarStream.default.extract();

    const writeFiles = []; // Keep track of files to write

    extract.on('entry', (header, stream, next) => {
      if (header.type === 'file' && header.name.length > 0) {
        const filePath = _path.default.join(dirPath, header.name);

        const fileWritten = writeStreamTo(stream, filePath).then(() => {
          next(); // Extract next entry after file has been written
        });
        writeFiles.push(fileWritten);
      } else {
        next();
      }
    });
    extract.on('error', err => {
      reject(err);
    });
    extract.on('finish', () => {
      // Wait until all files have been written before resolving
      Promise.all(writeFiles).then(() => resolve(writeFiles.length), reject);
    });
    stream.pipe(extract);
  });
}